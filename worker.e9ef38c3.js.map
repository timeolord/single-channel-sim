{"mappings":"AAEA,MAAMA,OACFC,YAAYC,GACVC,KAAKC,MAAQ,UAAYF,EACzBC,KAAKE,MAAQ,QAAUH,CACzB,CACAI,SACE,IAAIC,EAAIC,KAAKC,MAAMN,KAAKC,MAAQ,OAChCD,KAAKC,MAAQ,OAASD,KAAKC,MAAU,MAAFG,GAAe,MAAJA,EAE3CJ,KAAKC,MAAQ,IACdD,KAAKC,OAAS,YAGhBG,EAAIC,KAAKC,MAAMN,KAAKE,MAAQ,OAC1BF,KAAKE,MAAQ,OAASF,KAAKE,MAAU,MAAFE,GAAe,KAAJA,EAE7CJ,KAAKE,MAAQ,IACdF,KAAKE,OAAS,YAGhB,IAAIK,EAAIP,KAAKC,MAAQD,KAAKE,MAMxB,OAJGK,EAAI,IACPA,GAAK,YAGEC,WAAW,qBAAuBA,WAAWD,GACxD,EAIJ,SAASE,MAAMC,EAAOC,GAClB,MAAMC,EAASD,EAAMD,EACrB,OAAOG,MAAMC,KAAK,CAAEF,WAAU,CAACG,EAAGC,IAAMN,EAAQM,GACpD,CACA,SAASC,KAAKC,EAAOC,GACjB,GAAS,GAALA,EACF,OAAOD,EAET,GAAIC,EAAI,EAAG,CACT,IAAK,IAAIH,EAAI,EAAGA,EAAIG,EAAGH,IACrBE,EAAME,QAER,OAAOF,CACT,CAEE,IAAK,IAAIG,EAAI,EAAGA,EAAIF,EAAGE,IACrBH,EAAMI,MAER,OAAOJ,CAEb,CACA,SAASK,QAAQC,EAAGC,EAAIC,GACpB,OAAOF,EAAEG,KAAI,CAACZ,EAAGC,EAAGY,IAAQA,EAAIC,MAAMb,EAAGA,EAAIS,KAAKI,MAAM,GAAIJ,EAAKC,EACrE,CACA,SAASI,IAAIN,EAAGO,GAGZ,OAFSP,EAAEG,KAAI,CAACK,EAAGhB,IAAMQ,EAAER,GAAKe,EAAEf,KACtBiB,QAAO,CAACT,EAAGO,IAAMP,EAAIO,GAErC,CACA,SAASG,cAAcC,GACnB,OAAOC,EAAEjC,SAAWgC,CACxB,CACA,SAASE,YAAYC,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUC,EAAGC,EAASC,EAAUV,GACxG,IAAIW,EAAgB,EAChBC,EAAO,EACPC,EAAQP,EACRQ,EAAkB,GAClBC,EAAa,IAAIC,OACjBC,EAAU,IAAIvC,MAAMR,KAAKC,MAAMsC,EAAUC,IAG7C,SAASQ,EAAgBC,EAAWC,GAClC,KAAOR,EAAOO,GAAW,CAEvB,IAAK,IAAIE,KAAYhB,EACfe,EAAEP,GAAOQ,GAAY,EACvBN,EAAWM,IAAanD,KAAKoD,IAAIrB,EAAEjC,UAAYoD,EAAEP,GAAOQ,GAGxDN,EAAWM,GAAYZ,EAAU,EAIrC,IAAIc,EAAcd,EAAU,EAC5B,IAAK,IAAIe,KAAYnB,EACfU,EAAWS,GAAYD,IACzBA,EAAcR,EAAWS,GACzBV,EAAkBU,GAItB,GAAIZ,EAAOW,EAAcJ,EAAW,CAElC,IAAK,IAAIM,EAAuBd,EAAgB,EAC3Cc,GAAwBvD,KAAKC,OAAOyC,EAAOW,GAAeb,GAC1De,IACCR,EAAQQ,IAAyBjB,EAAEH,EAAiBQ,GAASd,cAAcC,GAEjFa,EAAQC,EACRF,GAAcW,EACdZ,EAAgBzC,KAAKC,MAAMyC,EAAOF,EACpC,KACK,CAGH,IAAK,IAAIgB,EAAuBf,EAAgB,EAC3Ce,GAAwBxD,KAAKC,MAAMgD,EAAYT,GAC/CgB,IAECT,EAAQS,IAAyBlB,EAAEH,EAAiBQ,GAASd,cAAcC,GAGjFY,EAAOO,EACPR,EAAgBzC,KAAKC,MAAMyC,EAAOF,EACpC,CACF,CACF,CAQA,OAvDAO,EAAQN,IAAkBH,EAAEH,EAAiBQ,GAASd,cAAcC,GAkDpEkB,EAAgBX,EAAUJ,GAG1Be,EAAgBT,EAASL,GAElBa,CACX,CACA,SAASU,WAAWxB,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUvB,EAAGwB,EAAGC,EAASC,EAAUV,GAC1G,OAAO1B,MAAM,EAAGU,GAAGQ,KAAI,IAAMU,YAAYC,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUC,EAAGC,EAASC,EAAUV,IACpI,CACA,SAAS4B,UAAUvC,EAAGO,GACpB,OAAOP,EAAEG,KAAI,CAACK,EAAGhB,IAAMgB,EAAID,EAAEf,IAC/B,CACA,SAASgD,YAAY1B,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUvB,EAAGwB,EAAGC,EAASC,GAEjG,OADuBiB,WAAWxB,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUvB,EAAGwB,EAAGC,EAASC,GAC1FZ,QAAO,CAACT,EAAGO,IAAMgC,UAAUvC,EAAGO,KAAIJ,KAAIK,GAAKA,EAAIb,GAC3E,CACA,SAAS8C,aAAaC,EAAQ/C,GAC5B,OAAO+C,EAAOjC,QAAO,CAACT,EAAGO,IAAMgC,UAAUvC,EAAGO,KAAIJ,KAAIK,GAAKA,EAAIb,GAC/D,CACA,SAASgD,WAAWC,EAAc9B,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUC,EAAGC,EAASyB,EAAmBC,GAC9H,IAAIzB,EAAW,EAAIwB,EACfE,EAAQ,OAAUD,EAAkBD,GACpCG,EAAUnE,KAAKoE,MAAM,EAAIF,GACzBG,EAAUjE,OAAO+D,EAASA,EAAU,GAAG7C,KAAIK,GAAK3B,KAAKsE,KAAK3C,EAAEA,GAAK,EAAEuC,EAAMA,MAC7EG,EAAUA,EAAQ/C,KAAIK,GAAKA,EAAI0C,EAAQzC,QAAO,CAACT,EAAGO,IAAMP,EAAIO,MAC5D,IAAI6C,EAAiB,IAAI/D,MAAM2D,GAASK,KAAK,GAAGC,OAC5Cd,YAAY1B,EAAYC,EAAYC,EAAkBC,EAAaC,EAAU0B,EAAczB,EAAGC,EAAW4B,EAAU3B,EAAWA,GAAUlB,KAAIK,GAAKA,EAAIoC,KAGzJ,MAAO,CAACW,kBAFgB9D,KAAKA,KAAK,IAAI2D,GAAiBJ,IAAWA,GAElBQ,gBAD1BzD,QAAQ,IAAIqD,GAAiB,EAAK,EAAIJ,EAAU,GAAG7C,KAAIK,GAAKF,IAAIE,EAAG0C,KACL7B,SAAYA,EACpG,CACA,SAASoC,UAAUb,EAAc9B,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUvB,EAAGwB,EAAGC,EAASyB,EAAmBC,GAChI,IAAIY,EAAQzE,MAAM,EAAGU,GAAGQ,KAAI,IAAMwC,WAAWC,EAAc9B,EAAYC,EAAYC,EAAkBC,EAAaC,EAAUC,EAAGC,EAASyB,EAAmBC,GAAiBU,gBAAgB/C,QAAO,CAACT,EAAGO,IAAM1B,KAAK8E,IAAI3D,EAAGO,OACrNqD,EAAkB,IAAIvE,MAAMR,KAAKoE,MAA4B,KAArBpE,KAAK8E,OAAOD,KAAeL,KAAK,GAE5E,OADAK,EAAMG,SAAQrD,GAAKoD,GAAiB/E,KAAKoE,MAAMzC,QACxCoD,EAAgBzD,KAAIK,GAAKA,EAAIoD,EAAgBnD,QAAO,CAACT,EAAGO,IAAMP,EAAIO,KAC7E,CACA,SAASuD,KAAKpE,GACV,OAAOA,EAAMe,QAAO,CAACT,EAAGO,IAAMP,EAAIO,IAAKb,EAAMN,MACjD,CACA,SAAS2E,SAASrE,GACd,IAAIsE,EAAIF,KAAKpE,GACb,OAAOoE,KAAKpE,EAAMS,KAAIK,IAAMA,EAAIwD,IAAMxD,EAAIwD,KAC9C,CACA,SAASC,kBAAkBvE,GACvB,OAAOb,KAAKqF,KAAKH,SAASrE,GAC9B,C","sources":["src/worker.js"],"sourcesContent":["//Random number generation with the same behaviour as the original paper\r\n\r\nclass Random {\r\n    constructor(seed){\r\n      this.jSeed = 536870911 + seed\r\n      this.kSeed = 8388607 + seed\r\n    }\r\n    random(){\r\n      var k = Math.floor(this.jSeed / 53668)\r\n      this.jSeed = 40014 * (this.jSeed - k*53668) - k * 12211\r\n  \r\n      if(this.jSeed < 0){\r\n        this.jSeed += 2147483563;\r\n      }\r\n  \r\n      k = Math.floor(this.kSeed / 52774);\r\n        this.kSeed = 40692 * (this.kSeed - k*52774) - k * 3791;\r\n  \r\n      if(this.kSeed < 0){\r\n        this.kSeed += 2147483399;\r\n      }\r\n  \r\n      var Z = this.jSeed - this.kSeed;\r\n  \r\n        if(Z < 1){\r\n        Z += 2147483562;\r\n      } \r\n  \r\n        return parseFloat(4.65661305739177e-10 * parseFloat(Z));\r\n    }\r\n  }\r\n\r\n  \r\nfunction range(start, end){\r\n    const length = end - start;\r\n    return Array.from({ length }, (_, i) => start + i);\r\n}\r\nfunction drop(array, n){\r\n    if (n == 0){\r\n      return array\r\n    }\r\n    if (n > 0) {\r\n      for (let i = 0; i < n; i++){\r\n        array.shift()\r\n      }\r\n      return array\r\n    }\r\n    else {\r\n      for (let i = 0; i > n; i--){\r\n        array.pop()\r\n      }\r\n      return array\r\n    }\r\n}\r\nfunction windows(a, sz, skip) {\r\n    return a.map((_, i, ary) => ary.slice(i, i + sz)).slice(0, -sz + skip);\r\n}\r\nfunction dot(a, b){\r\n    let t1 = a.map((x, i) => a[i] * b[i])\r\n    let t2 = t1.reduce((a, b) => a + b)\r\n    return t2;\r\n}\r\nfunction generateNoise(noise){\r\n    return r.random() * noise;\r\n}\r\nfunction singletrace(qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, timeStep, noise){\r\n    let timeIncrement = 0\r\n    let time = 0\r\n    let state = initalState\r\n    let minimumPosition = \"\"\r\n    let decayTimes = new Object()\r\n    let current = new Array(Math.floor(maxTime / timeStep))\r\n    current[timeIncrement] = -u*conductivityList[state] + generateNoise(noise); /* current at t = 0 */\r\n  \r\n    function singletrace_aux(timeLimit, q) {\r\n      while (time < timeLimit) {\r\n        /* calculate decay times into prospective new states */\r\n        for (let newState in conductivityList) {\r\n          if (q[state][newState] > 0.)\r\n            decayTimes[newState] = -Math.log(r.random()) / q[state][newState];\r\n          else\r\n            /* no decay in this direction */\r\n            decayTimes[newState] = maxTime + 1.;\r\n            /* tmax + 1. is infinity() for this purpose */\r\n        }\r\n        /* find minimum decay time and resp. new state */\r\n        let minimumTime = maxTime + 2;\r\n        for (let newState in conductivityList) {\r\n          if (decayTimes[newState] < minimumTime) {\r\n            minimumTime = decayTimes[newState];\r\n            minimumPosition = newState;\r\n          }\r\n        }\r\n        /* check if transmitter pulse duration is exceeded */\r\n        if (time + minimumTime < timeLimit) {\r\n          /* write to current[] and update state and time */\r\n          for (let timeIncrementSojourn = timeIncrement + 1;\r\n               timeIncrementSojourn <= Math.floor((time + minimumTime) / timeStep);\r\n               timeIncrementSojourn++) {\r\n                current[timeIncrementSojourn] = -u*conductivityList[state] + generateNoise(noise);\r\n               }\r\n          state = minimumPosition; /* new state */\r\n          time = time + minimumTime; /* new time */\r\n          timeIncrement = Math.floor(time / timeStep);\r\n        }\r\n        else {\r\n          /* clip sojourn at the end of the transmitter pulse */\r\n          /* write to current[] and update time */\r\n          for (let timeIncrementSojourn = timeIncrement + 1;\r\n               timeIncrementSojourn <= Math.floor(timeLimit / timeStep);\r\n               timeIncrementSojourn++)\r\n               {\r\n                current[timeIncrementSojourn] = -u*conductivityList[state] + generateNoise(noise);\r\n               }\r\n          /* keep old state */\r\n          time = timeLimit; /* new time */\r\n          timeIncrement = Math.floor(time / timeStep);\r\n        }\r\n      } /* while */\r\n    }\r\n  \r\n      /* transmitter pulse */\r\n    singletrace_aux(duration, qflatpulse)\r\n  \r\n      /* relaxation after transmitter pulse */\r\n    singletrace_aux(maxTime, qflatpause)\r\n  \r\n    return current\r\n}\r\nfunction tracetable(qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, timeStep, noise){\r\n    return range(0, n).map(() => singletrace(qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, timeStep, noise))\r\n}\r\nfunction addvector(a, b){\r\n  return a.map((x, i) => x + b[i])\r\n}\r\nfunction meancurrent(qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, timeStep){\r\n    let tracetableResult = tracetable(qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, timeStep)\r\n    return tracetableResult.reduce((a, b) => addvector(a, b)).map(x => x / n)\r\n}\r\nfunction meancurrent2(traces, n) {\r\n  return traces.reduce((a, b) => addvector(a, b)).map(x => x / n)\r\n}\r\nfunction filtertest(ensembleSize, qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, samplingFrequency, cutoffFrequency){\r\n    let timeStep = 1 / samplingFrequency\r\n    let sigma = 0.1325 / (cutoffFrequency / samplingFrequency);\r\n    let filterN = Math.round(4 * sigma)\r\n    let filterA = range(-filterN, filterN + 1).map(x => Math.exp(-x*x / (2*sigma*sigma)))\r\n    filterA = filterA.map(x => x / filterA.reduce((a, b) => a + b))\r\n    let sampledCurrent = new Array(filterN).fill(0).concat(\r\n        meancurrent(qflatpulse, qflatpause, conductivityList, initalState, duration, ensembleSize, u, maxTime + (filterN * timeStep), timeStep).map(x => x * ensembleSize))\r\n    let unfilteredCurrent = drop(drop([...sampledCurrent], filterN), -filterN)\r\n    let filteredCurrent = windows([...sampledCurrent], 1 + (2 * filterN), 1).map(x => dot(x, filterA))\r\n    return {\"unfilteredCurrent\": unfilteredCurrent, \"filteredCurrent\": filteredCurrent, \"timeStep\": timeStep}\r\n}\r\nfunction peakEPSCs(ensembleSize, qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, samplingFrequency, cutoffFrequency){\r\n    let peaks = range(0, n).map(() => filtertest(ensembleSize, qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, samplingFrequency, cutoffFrequency).filteredCurrent.reduce((a, b) => Math.min(a, b)))\r\n    let peakFrequencies = new Array(Math.round(-Math.min(...peaks) * 1.5)).fill(0)\r\n    peaks.forEach(x => peakFrequencies[-Math.round(x)]++)\r\n    return peakFrequencies.map(x => x / peakFrequencies.reduce((a, b) => a + b))\r\n}\r\nfunction mean(array){\r\n    return array.reduce((a, b) => a + b) / array.length\r\n}\r\nfunction variance(array){\r\n    let m = mean(array)\r\n    return mean(array.map(x => (x - m) * (x - m)))\r\n}\r\nfunction standardDeviation(array){\r\n    return Math.sqrt(variance(array))\r\n}\r\n/* function CVdata(maxN, ensembleSize, options){\r\n\r\n    function aux(n, options) {\r\n        return meancurrent(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, n, options.u, options.maxTime, options.timeStep)\r\n    }\r\n    function roundAux(i){\r\n        return JSON.stringify({x: i.x.toPrecision(3), y: i.y.toPrecision(3)})\r\n    }\r\n    \r\n    let resultData = new Set()\r\n\r\n    for (let ensemble = 0; ensemble < ensembleSize; ensemble++){\r\n        let currents = range(5, maxN).map(x => aux(x, options))\r\n        for (let i = 0; i < currents[0].length; i++){\r\n            let current = []\r\n            for (let j = 0; j < currents.length; j++){\r\n                current.push(currents[j][i])\r\n            }\r\n            let meanCurrent = mean(current)\r\n            let varianceCurrent = variance(current)\r\n            resultData.add(roundAux({x: meanCurrent, y: varianceCurrent}))\r\n        }\r\n    }\r\n    return resultData\r\n} */\r\n\r\n/* function CVdata(maxN, ensembleSize, windowSize, options){\r\n\r\n    function aux(n, options) {\r\n        return tracetable(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, n, options.u, options.maxTime, options.timeStep, options.singlechannelNoise)\r\n    }\r\n    function roundAux(i){\r\n        const decimals = 4\r\n        return JSON.stringify({x: i.x.toFixed(decimals), y: i.y.toFixed(decimals)})\r\n    }\r\n    \r\n    let resultData = new Set()\r\n\r\n    for (let ensemble = 0; ensemble < ensembleSize; ensemble++){\r\n        let currents = aux(maxN, options)\r\n        for (let i = 0; i < currents[0].length; i++){\r\n            let current = []\r\n            for (let j = 0; j < currents.length; j++){\r\n                current.push(mean(currents[j].slice(i, i+windowSize)))\r\n            }\r\n            let meanCurrent = mean(current)\r\n            let varianceCurrent = variance(current)\r\n            resultData.add(roundAux({x: meanCurrent, y: varianceCurrent}))\r\n        }\r\n    }\r\n    return [...resultData].map(x => JSON.parse(x))\r\n} */\r\n\r\nfunction CVdata(maxN, ensembleSize, windowSize, options){\r\n    const decimals = 3\r\n\r\n    function aux(n, options) {\r\n        return tracetable(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, n, options.u, options.maxTime, options.timeStep, options.singlechannelNoise)\r\n    }\r\n    \r\n    let resultData = []\r\n\r\n    for (let ensemble = 0; ensemble < ensembleSize; ensemble++){\r\n        let currents = aux(maxN, options)\r\n        for (let i = 0; i < currents[0].length; i++){\r\n            let current = []\r\n            for (let j = 0; j < currents.length; j++){\r\n                current.push(mean(currents[j].slice(i, i+windowSize)))\r\n            }\r\n            let meanCurrent = mean(current)\r\n            let varianceCurrent = variance(current)\r\n            if (resultData[meanCurrent.toFixed(decimals)] === undefined){\r\n                resultData[meanCurrent.toFixed(decimals)] = varianceCurrent\r\n            } else {\r\n                const value = resultData[meanCurrent.toFixed(decimals)]\r\n                resultData[meanCurrent.toFixed(decimals)] = (value + varianceCurrent) / 2\r\n            }\r\n        }\r\n    }\r\n    return Object.keys(resultData).map(x => ({x: x, y: resultData[x]}))\r\n}\r\n\r\n\r\nonmessage = (e) => {\r\n    e.data.clist = JSON.parse(e.data.clist)\r\n    r = new Random(e.data.randomSeed)\r\n    e.data.singletraces = tracetable(e.data.qflatpulse, e.data.qPause, e.data.clist, e.data.initalState, e.data.duration, e.data.n, e.data.u, e.data.maxTime, e.data.timeStep, e.data.singlechannelNoise)\r\n    e.data.meantrace = meancurrent2(e.data.singletraces, e.data.n)\r\n    e.data.stderror = standardDeviation(e.data.meantrace) / Math.sqrt(e.data.n)\r\n    e.data.CVdata = CVdata(e.data.n, e.data.ensembleSize, 5, e.data)\r\n    postMessage(e.data)\r\n  }\r\n  "],"names":["Random","constructor","seed","this","jSeed","kSeed","random","k","Math","floor","Z","parseFloat","range","start","end","length","Array","from","_","i","drop","array","n","shift","i1","pop","windows","a","sz","skip","map","ary","slice","dot","b","x","reduce","generateNoise","noise","r","singletrace","qflatpulse","qflatpause","conductivityList","initalState","duration","u","maxTime","timeStep","timeIncrement","time","state","minimumPosition","decayTimes","Object","current","singletrace_aux","timeLimit","q","newState","log","minimumTime","newState1","timeIncrementSojourn","timeIncrementSojourn1","tracetable","addvector","meancurrent","meancurrent2","traces","filtertest","ensembleSize","samplingFrequency","cutoffFrequency","sigma","filterN","round","filterA","exp","sampledCurrent","fill","concat","unfilteredCurrent","filteredCurrent","peakEPSCs","peaks","min","peakFrequencies","forEach","mean","variance","m","standardDeviation","sqrt"],"version":3,"file":"worker.e9ef38c3.js.map"}