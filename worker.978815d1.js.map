{"mappings":"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","sources":["src/worker.js"],"sourcesContent":["//Random number generation with the same behaviour as the original paper\r\n\r\nclass Random {\r\n    constructor(seed){\r\n      this.jSeed = 536870911 + seed\r\n      this.kSeed = 8388607 + seed\r\n    }\r\n    random(){\r\n      var k = Math.floor(this.jSeed / 53668)\r\n      this.jSeed = 40014 * (this.jSeed - k*53668) - k * 12211\r\n  \r\n      if(this.jSeed < 0){\r\n        this.jSeed += 2147483563;\r\n      }\r\n  \r\n      k = Math.floor(this.kSeed / 52774);\r\n        this.kSeed = 40692 * (this.kSeed - k*52774) - k * 3791;\r\n  \r\n      if(this.kSeed < 0){\r\n        this.kSeed += 2147483399;\r\n      }\r\n  \r\n      var Z = this.jSeed - this.kSeed;\r\n  \r\n        if(Z < 1){\r\n        Z += 2147483562;\r\n      } \r\n  \r\n        return parseFloat(4.65661305739177e-10 * parseFloat(Z));\r\n    }\r\n  }\r\n\r\nfunction range(start, end){\r\n    const length = end - start;\r\n    return Array.from({ length }, (_, i) => start + i);\r\n}\r\nfunction drop(array, n){\r\n    if (n == 0){\r\n      return array\r\n    }\r\n    if (n > 0) {\r\n      for (let i = 0; i < n; i++){\r\n        array.shift()\r\n      }\r\n      return array\r\n    }\r\n    else {\r\n      for (let i = 0; i > n; i--){\r\n        array.pop()\r\n      }\r\n      return array\r\n    }\r\n}\r\nfunction windows(a, sz, skip) {\r\n    return a.map((_, i, ary) => ary.slice(i, i + sz)).slice(0, -sz + skip);\r\n}\r\nfunction dot(a, b){\r\n    let t1 = a.map((x, i) => a[i] * b[i])\r\n    let t2 = t1.reduce((a, b) => a + b)\r\n    return t2;\r\n}\r\n\r\nfunction generateNoise(noise){\r\n  function gaussianRandom(mean=0, stdev=1) {\r\n    let u = 1 - r.random(); // Converting [0,1) to (0,1]\r\n    let v = r.random();\r\n    let z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\r\n    // Transform to the desired mean and standard deviation:\r\n    return z * stdev + mean;\r\n    }\r\n    return gaussianRandom(0, noise);\r\n}\r\nfunction singletrace(qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, timeStep, noise){\r\n    let timeIncrement = 0\r\n    let time = 0\r\n    let state = initalState\r\n    let minimumPosition = \"\"\r\n    let decayTimes = new Object()\r\n    let current = new Array(Math.floor(maxTime / timeStep))\r\n    current[timeIncrement] = -u*conductivityList[state] + generateNoise(noise); /* current at t = 0 */\r\n  \r\n    function singletrace_aux(timeLimit, q) {\r\n      while (time < timeLimit) {\r\n        /* calculate decay times into prospective new states */\r\n        for (let newState in conductivityList) {\r\n          if (q[state][newState] > 0.)\r\n            decayTimes[newState] = -Math.log(r.random()) / q[state][newState];\r\n          else\r\n            /* no decay in this direction */\r\n            decayTimes[newState] = maxTime + 1.;\r\n            /* tmax + 1. is infinity() for this purpose */\r\n        }\r\n        /* find minimum decay time and resp. new state */\r\n        let minimumTime = maxTime + 2;\r\n        for (let newState in conductivityList) {\r\n          if (decayTimes[newState] < minimumTime) {\r\n            minimumTime = decayTimes[newState];\r\n            minimumPosition = newState;\r\n          }\r\n        }\r\n        /* check if transmitter pulse duration is exceeded */\r\n        if (time + minimumTime < timeLimit) {\r\n          /* write to current[] and update state and time */\r\n          for (let timeIncrementSojourn = timeIncrement + 1;\r\n               timeIncrementSojourn <= Math.floor((time + minimumTime) / timeStep);\r\n               timeIncrementSojourn++) {\r\n                current[timeIncrementSojourn] = -u*conductivityList[state] + generateNoise(noise);\r\n               }\r\n          state = minimumPosition; /* new state */\r\n          time = time + minimumTime; /* new time */\r\n          timeIncrement = Math.floor(time / timeStep);\r\n        }\r\n        else {\r\n          /* clip sojourn at the end of the transmitter pulse */\r\n          /* write to current[] and update time */\r\n          for (let timeIncrementSojourn = timeIncrement + 1;\r\n               timeIncrementSojourn <= Math.floor(timeLimit / timeStep);\r\n               timeIncrementSojourn++)\r\n               {\r\n                current[timeIncrementSojourn] = -u*conductivityList[state] + generateNoise(noise);\r\n               }\r\n          /* keep old state */\r\n          time = timeLimit; /* new time */\r\n          timeIncrement = Math.floor(time / timeStep);\r\n        }\r\n      } /* while */\r\n    }\r\n  \r\n      /* transmitter pulse */\r\n    singletrace_aux(duration, qflatpulse)\r\n  \r\n      /* relaxation after transmitter pulse */\r\n    singletrace_aux(maxTime, qflatpause)\r\n  \r\n    return current\r\n}\r\nfunction tracetable(qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, timeStep, noise){\r\n    return range(0, n).map(() => singletrace(qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, timeStep, noise))\r\n}\r\nfunction addvector(a, b){\r\n  return a.map((x, i) => x + b[i])\r\n}\r\nfunction meancurrent(qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, timeStep){\r\n    let tracetableResult = tracetable(qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, timeStep)\r\n    return tracetableResult.reduce((a, b) => addvector(a, b)).map(x => x / n)\r\n}\r\nfunction sumcurrent(traces, n) {\r\n  return traces.reduce((a, b) => addvector(a, b))//.map(x => x / n)\r\n}\r\nfunction filtertest(ensembleSize, qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, samplingFrequency, cutoffFrequency){\r\n    let timeStep = 1 / samplingFrequency\r\n    let sigma = 0.1325 / (cutoffFrequency / samplingFrequency);\r\n    let filterN = Math.round(4 * sigma)\r\n    let filterA = range(-filterN, filterN + 1).map(x => Math.exp(-x*x / (2*sigma*sigma)))\r\n    filterA = filterA.map(x => x / filterA.reduce((a, b) => a + b))\r\n    let sampledCurrent = new Array(filterN).fill(0).concat(\r\n        meancurrent(qflatpulse, qflatpause, conductivityList, initalState, duration, ensembleSize, u, maxTime + (filterN * timeStep), timeStep).map(x => x * ensembleSize))\r\n    let unfilteredCurrent = drop(drop([...sampledCurrent], filterN), -filterN)\r\n    let filteredCurrent = windows([...sampledCurrent], 1 + (2 * filterN), 1).map(x => dot(x, filterA))\r\n    return {\"unfilteredCurrent\": unfilteredCurrent, \"filteredCurrent\": filteredCurrent, \"timeStep\": timeStep}\r\n}\r\nfunction peakEPSCs(ensembleSize, qflatpulse, qflatpause, conductivityList, initalState, duration, n, u, maxTime, samplingFrequency, cutoffFrequency){\r\n    let peaks = range(0, n).map(() => filtertest(ensembleSize, qflatpulse, qflatpause, conductivityList, initalState, duration, u, maxTime, samplingFrequency, cutoffFrequency).filteredCurrent.reduce((a, b) => Math.min(a, b)))\r\n    let peakFrequencies = new Array(Math.round(-Math.min(...peaks) * 1.5)).fill(0)\r\n    peaks.forEach(x => peakFrequencies[-Math.round(x)]++)\r\n    return peakFrequencies.map(x => x / peakFrequencies.reduce((a, b) => a + b))\r\n}\r\nfunction mean(array){\r\n    return array.reduce((a, b) => a + b) / array.length\r\n}\r\nfunction variance(array){\r\n    let m = mean(array)\r\n    return mean(array.map(x => (x - m) * (x - m)))\r\n}\r\nfunction standardDeviation(array){\r\n    return Math.sqrt(variance(array))\r\n}\r\n/* function CVdata(maxN, ensembleSize, options){\r\n\r\n    function aux(n, options) {\r\n        return meancurrent(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, n, options.u, options.maxTime, options.timeStep)\r\n    }\r\n    function roundAux(i){\r\n        return JSON.stringify({x: i.x.toPrecision(3), y: i.y.toPrecision(3)})\r\n    }\r\n    \r\n    let resultData = new Set()\r\n\r\n    for (let ensemble = 0; ensemble < ensembleSize; ensemble++){\r\n        let currents = range(5, maxN).map(x => aux(x, options))\r\n        for (let i = 0; i < currents[0].length; i++){\r\n            let current = []\r\n            for (let j = 0; j < currents.length; j++){\r\n                current.push(currents[j][i])\r\n            }\r\n            let meanCurrent = mean(current)\r\n            let varianceCurrent = variance(current)\r\n            resultData.add(roundAux({x: meanCurrent, y: varianceCurrent}))\r\n        }\r\n    }\r\n    return resultData\r\n} */\r\n\r\n/* function CVdata(maxN, ensembleSize, windowSize, options){\r\n\r\n    function aux(n, options) {\r\n        return tracetable(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, n, options.u, options.maxTime, options.timeStep, options.singlechannelNoise)\r\n    }\r\n    function roundAux(i){\r\n        const decimals = 4\r\n        return JSON.stringify({x: i.x.toFixed(decimals), y: i.y.toFixed(decimals)})\r\n    }\r\n    \r\n    let resultData = new Set()\r\n\r\n    for (let ensemble = 0; ensemble < ensembleSize; ensemble++){\r\n        let currents = aux(maxN, options)\r\n        for (let i = 0; i < currents[0].length; i++){\r\n            let current = []\r\n            for (let j = 0; j < currents.length; j++){\r\n                current.push(mean(currents[j].slice(i, i+windowSize)))\r\n            }\r\n            let meanCurrent = mean(current)\r\n            let varianceCurrent = variance(current)\r\n            resultData.add(roundAux({x: meanCurrent, y: varianceCurrent}))\r\n        }\r\n    }\r\n    return [...resultData].map(x => JSON.parse(x))\r\n} */\r\n\r\nfunction CVdata(maxN, ensembleSize, windowSize, options){\r\n    function aux(n, options) {\r\n      return range(0, n).map(() => sumcurrent(tracetable(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, options.n, options.u, options.maxTime, options.timeStep, options.singlechannelNoise), options.n))\r\n        //return tracetable(options.qflatpulse, options.qPause, options.clist, options.initalState, options.duration, n, options.u, options.maxTime, options.timeStep, options.singlechannelNoise)\r\n    }\r\n    \r\n    let resultData = []\r\n    //ensembleSize = 1\r\n\r\n    let currents = aux(ensembleSize, options)\r\n    for (let i = 0; i < currents[0].length; i++){\r\n      let current = []\r\n      for (let j = 0; j < currents.length; j++){\r\n          current.push(currents[j][i])\r\n      }\r\n      let meanCurrent = mean(current)\r\n      let varianceCurrent = variance(current)\r\n      variances.push({x: i, y: varianceCurrent})\r\n      means.push({x: i, y: meanCurrent})\r\n      resultData[meanCurrent] = varianceCurrent\r\n      //if (resultData[meanCurrent] === undefined){\r\n      //    resultData[meanCurrent] = varianceCurrent\r\n      //} else {\r\n      //    const value = resultData[meanCurrent]\r\n      //    resultData[meanCurrent] = (value + varianceCurrent) / 2\r\n      //}\r\n    }\r\n    return Object.keys(resultData).map(x => ({x: parseFloat(x), y: resultData[x]}))\r\n}\r\n\r\nonmessage = (e) => {\r\n  variances = []\r\n  means = []\r\n  //e.data.clist = JSON.parse(e.data.clist)\r\n  r = new Random(e.data.randomSeed)\r\n  e.data.singletraces = tracetable(e.data.qflatpulse, e.data.qPause, e.data.clist, e.data.initalState, e.data.duration, e.data.n, e.data.u, e.data.maxTime, e.data.timeStep, e.data.singlechannelNoise)\r\n  e.data.meantrace = sumcurrent(e.data.singletraces, e.data.n)\r\n  e.data.stderror = standardDeviation(e.data.meantrace) / Math.sqrt(e.data.n)\r\n  e.data.CVdata = CVdata(e.data.n, e.data.ensembleSize, 1, e.data)\r\n  e.data.variances = variances\r\n  e.data.means = means\r\n  postMessage(e.data)\r\n  }\r\n  "],"names":["Random","constructor","seed","this","jSeed","kSeed","random","k","Math","floor","Z","parseFloat","range","start","end","length","Array","from","_","i","drop","array","n","shift","i1","pop","windows","a","sz","skip","map","ary","slice","dot","b","x","reduce","generateNoise","noise","mean","stdev","u","r","v","sqrt","log","cos","PI","gaussianRandom","singletrace","qflatpulse","qflatpause","conductivityList","initalState","duration","maxTime","timeStep","timeIncrement","time","state","minimumPosition","decayTimes","Object","current","singletrace_aux","timeLimit","q","newState","minimumTime","newState1","timeIncrementSojourn","timeIncrementSojourn1","tracetable","addvector","meancurrent","sumcurrent","traces","filtertest","ensembleSize","samplingFrequency","cutoffFrequency","sigma","filterN","round","filterA","exp","sampledCurrent","fill","concat","unfilteredCurrent","filteredCurrent","peakEPSCs","peaks","min","peakFrequencies","forEach","variance","m","standardDeviation"],"version":3,"file":"worker.978815d1.js.map"}